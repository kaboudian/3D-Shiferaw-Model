<!DOCTYPE html>
<html>
<head>
    <title>Shiferaw</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    <script src='https://abubujs.org/libs/Abubu.latest.js' 
	    type='text/javascript'></script>

    <!-- editors and jQuery -->
    <script 
    src='https://cdnjs.cloudflare.com/ajax/libs/ace/1.4.5/ace.js'  
    type="text/javascript" charset="utf-8">
    </script>
    <script 
        src='https://cdnjs.cloudflare.com/ajax/libs/ace/1.4.5/mode-glsl.js'>
    </script>
    <script 
        src='https://cdnjs.cloudflare.com/ajax/libs/ace/1.4.5/theme-tomorrow.js'>
    </script>
    <script
        src='https://cdnjs.cloudflare.com/ajax/libs/ace/1.4.5/keybinding-vim.js'>
    </script>
    <script 
        src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js">
    </script>

<style>
/* unvisited link */
a:link {
    	color: blue;
}

/* visited link */
a:visited {
    	color: blue;
}

/* mouse over link */
a:hover {
    	color: hotpink;
}

/* selected link */
a:active {
    	color: blue;
}
/*
li{
    	margin : 10px 6px ;
} */

body {
	counter-reset: h1;
}


h1{
        max-width: 1024px ;
	text-align:left;
	color: white;
       	background-color: #00254c;
       	padding-left: 20px ;
       	padding-top: 10px ;
       	padding-bottom: 10px ;
       	border-radius: 10px;
}

h2 {
        max-width: 1024px ;
    	color: #00254c;
    	background-color: #e5e5e5 ;
    	padding-left: 20px ;
    	padding-top: 2.5px ;
    	padding-bottom: 2.5px ;

    	border-radius: 10px;
}

h3 {
        max-width: 1024px ;
    	color: #00254c;
    	background-color: #f0f0f0 ;
    	padding-left: 20px ;
    	padding-top: 2.5px ;
    	padding-bottom: 2.5px ;
    	border-radius: 10px;
}

h4 {
        max-width: 1024px ;
    	color: #00254c;
    	background-color: #fafafa ;
    	padding-left: 20px ;
    	padding-top: 2.5px ;
    	padding-bottom: 2.5px ;
    	border-radius: 10px;
}

p{
    max-width : 700px  ;
    padding-left: 10px ;
}
canvas.clickable:hover{
    cursor:pointer ;
    cursor:hand ;
}

.footer{
    position : fixed ; 
    max-width: 1024px ;
    border-radius:10px ;
    left : 0px ;
    width : 100% ;
    background-color: #fafafa;
    color:black ;
    bottom: 0px ;
    text-align : left ;
    font: 'italic 12pt Times' ;
}


div.relative {
  position: relative;
  height: 512px;
  border: 1px solid black;
  width:100% ;
} 

div.editor {
  position : absolute;
  top: 0px;
  right: 0;
  bottom: 0;
  left: 0;
  width:100%;
}

</style>

</head>
<!--&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&-->
<!-- body of the html page                                             -->
<!--&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&-->
<body onload='loadWebGL();'>
    <h1>The Shiferaw Model on an Atrial Structure</h1>
    <table>
        <tr>
            <td>
                <canvas id=canvas_1 width=512 height=512>
                    Your browser doesn't support HTML5.0
                </canvas>
            </td>
            <td>
                <canvas id=canvas_2 width=512 height=512>
                    Your browser doesn't support HTML5.0
                </canvas>
            </td>
        </tr>
        
    </table>
    <table style='width:100%' id=editors>
        <tr id='compEditors' style='display:none'>
            <td id='ecomp1'> 
                <h2>comp1 editor</h2>
                <div class=relative id=comp1EditorContainer>
                    <div class=editor id='comp1Editor'></div>
                </div>
            </td>
            <td id='ecomp2'>
                <h2>comp2 editor</h2>
                <div class=relative id=comp2EditorContainer>
                    <div class='editor' id=comp2Editor></div>
                </div>
            </td>
        </tr>

        <tr  id='initEditors' style='display:none'>
            <td id='einit1'> 
                <h2>init1 editor</h2>
                <div class=relative id=init1EditorContainer>
                    <div class=editor id='init1Editor'></div>
                </div>
            </td>
            <td id='einit2'>
                <h2>init2 editor</h2>
                <div class=relative id=init2EditorContainer>
                    <div class='editor' id=init2Editor></div>
                </div>
            </td>
        </tr>

    </table>
    <img src='structure.png' id='structure' style='display:none'></img>

    <h3>Instructions for modifiable sections.</h3>
<p>You can edit the source code for the initial conditions and the compute
shaders by accessing the <b>Source Code Editos</b> menu of the graphical
interface. Each class of editors can be toggled on and off. Remember that
you can save and reload your changes to each shader.</p>

<p>At the end of the comp2 shader source code lies the pacing period which
can be adjusted now by editing the source code. Any edit of the source
code will change the model mid-simulation.</p>

<p>Notice that GLSL does not allow for mixing of data types. So, floats
and integers cannot be mixed unless directly type casted.</p>

<!--&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&-->
<!-- All shaders included here (codes written in GLSL)                 -->
<!--&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&-->
<!-- ***************************************************************** -->
<script id='init1' type='x-shader-fragment'>#version 300 es 
/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
 * init1.frag
 * -----------------
 * Initialize colors 0-5 (inlcusive)
 *
 * PROGRAMMER   :   ABOUZAR KABOUDIAN
 * DATE         :   Tue 31 Mar 2020 15:07:04 (EDT)
 * PLACE        :   Chaos Lab @ GaTech, Atlanta, GA
 *@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
 */
precision highp float;
precision highp int ;
precision highp isampler2D ;
precision highp usampler2D ;

/*========================================================================
 * variable mapping
 *========================================================================
 */
// color0: old4 
#define CB      color0.r
#define CI      color0.g
#define CSRB    color0.b
#define CSRI    color0.a

// color1: old5
#define CNSR    color1.r
#define PO      color1.g
#define C1      color1.b
#define C2      color1.a

// color2: old6 
#define XI1     color2.r
#define XI2     color2.g
#define XI1S    color2.b
#define XI2S    color2.a

// color3: old7
#define C1S     color3.r
#define C2S     color3.g
#define CIT     color3.b
#define CBT     color3.a

// color4: old8
#define PI      color4.r
#define PB      color4.g
#define POX     color4.b
#define POS     color4.a

/*  color5: old9
    Contains only integer values!
    We will implement as floats 
    for shading runtime reliablity. */
#define NSB     color5.r
#define NSI     color5.g
#define XINACA  color5.b
#define XICA    color5.a

//  color6: old0 
#define vchannel r
#define vlt_txtr icolor6
#define VLT     color6.r 
#define TIME    color6.g

// color7: old1
#define XM      color7.r
#define XH      color7.g
#define XJ      color7.b
#define XR      color7.a

// color8: old2 
#define XS1     color8.r
#define QKS     color8.g
#define XKUR    color8.b
#define YKUR    color8.a

// color9: old3 
#define XTOF    color9.r 
#define YTOF    color9.g

/*========================================================================
 * all direction macros go here for safe access
 *========================================================================
 */
#define NORTH   dir0.r
#define SOUTH   dir0.g
#define EAST    dir0.b
#define WEST    dir0.a

#define UP      dir1.r
#define DOWN    dir1.g

/*========================================================================
 * packing and unpacking two integers to and from a single unsigned int.
 *========================================================================
 */
#define pack(i,j)   uint((uint(i)<<16)+uint(j))
#define unpack(I)   ivec2(uint(I)>>16, uint(I) & uint(65535) )



/*------------------------------------------------------------------------
 * total
 *------------------------------------------------------------------------
 */
#define bcal        24.0 
#define xkcal       7.0
#define srmax       47.0
#define srkd        0.6

// troponin 
#define Bt          70.0   
#define xkton       0.0327 
#define xktoff      0.0196
// xkton/xktoff
#define xktOnOff    (xkton/xktoff)
#define skx(ci)     ((ci)*Bt/((ci)+xktOnOff))

// calmodulin
#define bix(ci)     (bcal*(ci)/(xkcal+(ci)))

// SR buffering
#define six(ci)     (srmax*(ci)/(srkd+(ci)))

#define total(ci)   ((ci) + bix(ci) + six(ci))  /* skx(ci) */

/*------------------------------------------------------------------------
 * xfree
 *------------------------------------------------------------------------
 */
#define xx1(cit)  (104329.0-3126.0*(cit)+25.0*(cit)*(cit))
#define xfree(cit) (0.1*(-323.0+5.0*(cit)+sqrt(xx1(cit)))) 

/*------------------------------------------------------------------------
 * uptake
 *------------------------------------------------------------------------
 */
#define Ki      0.3
#define Knsr    800.0
#define HH      3.0
#define uptake(ci,vup) \
    (((vup)*(ci)*(ci)*(ci))/(Ki*Ki*Ki+(ci)*(ci)*(ci)))


in vec2 cc ;

layout (location = 0 ) out vec4 ocolor0 ;
layout (location = 1 ) out vec4 ocolor1 ;
layout (location = 2 ) out vec4 ocolor2 ;
layout (location = 3 ) out vec4 ocolor3 ;
layout (location = 4 ) out vec4 ocolor4 ;
layout (location = 5 ) out vec4 ocolor5 ;

void main(){
    // define local colors ...............................................
    vec4 color0, color1, color2, color3, color4, color5 ;

    // initialize the textures ...........................................
    
#define cxinit 820.
    // color0
    CB    = 0.2 ;
    CI    = 0.2 ;
    CSRB  = cxinit ;
    CSRI  = cxinit ;
    
    // color1
    CNSR  = cxinit ;
    PO    = 0.0 ;
    C1    = 0.0 ;
    C2    = 1.0 ;

    // color2
    XI1   = 0.0 ;
    XI2   = 0.0 ;
    XI1S  = 0.0 ;
    XI2S  = 0.0 ;

    // color3
    C1S   = 0.0 ;
    C2S   = 0.0 ;
    CIT   = total(0.2) ;
    CBT   = total(0.2) ;

    // color4
#define nbt 2500. 
#define nit 2500.
    PI    = 5.0/nbt ;
    PB    = 5.0/nit ;
    POX   = 0.0 ;
    POS   = 0.0 ;

    // color5
    NSB   = 5.0 ; 
    NSI   = 5.0 ; 

    // output the colors .................................................
    ocolor0 = vec4(color0) ;
    ocolor1 = vec4(color1) ;
    ocolor2 = vec4(color2) ;
    ocolor3 = vec4(color3) ;
    ocolor4 = vec4(color4) ;
    ocolor5 = vec4(color5) ;
    return  ;
}


</script><!-- end of init1 shader's source code -->

<!-- ***************************************************************** -->
<script id='init2' type='x-shader-fragment'>#version 300 es
/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
 * init2.frag
 * -----------------
 * Initialize colors 6-9 (inclusive)
 *
 * PROGRAMMER   :   ABOUZAR KABOUDIAN
 * DATE         :   Tue 31 Mar 2020 15:14:45 (EDT)
 * PLACE        :   Chaos Lab @ GaTech, Atlanta, GA
 *@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
 */
precision highp float;
precision highp int ;
precision highp isampler2D ;
precision highp usampler2D ;

/*========================================================================
 * variable mapping
 *========================================================================
 */
// color0: old4 
#define CB      color0.r
#define CI      color0.g
#define CSRB    color0.b
#define CSRI    color0.a

// color1: old5
#define CNSR    color1.r
#define PO      color1.g
#define C1      color1.b
#define C2      color1.a

// color2: old6 
#define XI1     color2.r
#define XI2     color2.g
#define XI1S    color2.b
#define XI2S    color2.a

// color3: old7
#define C1S     color3.r
#define C2S     color3.g
#define CIT     color3.b
#define CBT     color3.a

// color4: old8
#define PI      color4.r
#define PB      color4.g
#define POX     color4.b
#define POS     color4.a

/*  color5: old9
    Contains only integer values!
    We will implement as floats 
    for shading runtime reliablity. */
#define NSB     color5.r
#define NSI     color5.g
#define XINACA  color5.b
#define XICA    color5.a

//  color6: old0 
#define vchannel r
#define vlt_txtr icolor6
#define VLT     color6.r 
#define TIME    color6.g

// color7: old1
#define XM      color7.r
#define XH      color7.g
#define XJ      color7.b
#define XR      color7.a

// color8: old2 
#define XS1     color8.r
#define QKS     color8.g
#define XKUR    color8.b
#define YKUR    color8.a

// color9: old3 
#define XTOF    color9.r 
#define YTOF    color9.g

/*========================================================================
 * all direction macros go here for safe access
 *========================================================================
 */
#define NORTH   dir0.r
#define SOUTH   dir0.g
#define EAST    dir0.b
#define WEST    dir0.a

#define UP      dir1.r
#define DOWN    dir1.g

/*========================================================================
 * packing and unpacking two integers to and from a single unsigned int.
 *========================================================================
 */
#define pack(i,j)   uint((uint(i)<<16)+uint(j))
#define unpack(I)   ivec2(uint(I)>>16, uint(I) & uint(65535) )



/*------------------------------------------------------------------------
 * total
 *------------------------------------------------------------------------
 */
#define bcal        24.0 
#define xkcal       7.0
#define srmax       47.0
#define srkd        0.6

// troponin 
#define Bt          70.0   
#define xkton       0.0327 
#define xktoff      0.0196
// xkton/xktoff
#define xktOnOff    (xkton/xktoff)
#define skx(ci)     ((ci)*Bt/((ci)+xktOnOff))

// calmodulin
#define bix(ci)     (bcal*(ci)/(xkcal+(ci)))

// SR buffering
#define six(ci)     (srmax*(ci)/(srkd+(ci)))

#define total(ci)   ((ci) + bix(ci) + six(ci))  /* skx(ci) */

/*------------------------------------------------------------------------
 * xfree
 *------------------------------------------------------------------------
 */
#define xx1(cit)  (104329.0-3126.0*(cit)+25.0*(cit)*(cit))
#define xfree(cit) (0.1*(-323.0+5.0*(cit)+sqrt(xx1(cit)))) 

/*------------------------------------------------------------------------
 * uptake
 *------------------------------------------------------------------------
 */
#define Ki      0.3
#define Knsr    800.0
#define HH      3.0
#define uptake(ci,vup) \
    (((vup)*(ci)*(ci)*(ci))/(Ki*Ki*Ki+(ci)*(ci)*(ci)))

in vec2 cc ;

layout (location = 0 ) out vec4 ocolor6 ;
layout (location = 1 ) out vec4 ocolor7 ;
layout (location = 2 ) out vec4 ocolor8 ;
layout (location = 3 ) out vec4 ocolor9 ;

/*========================================================================
 * main body of the shader
 *========================================================================
 */
void main(){
    // define local colors ...............................................
    vec4 color6, color7, color8, color9 ;

    // color6
    VLT   = -90.0 ;
    TIME  = 0.0 ;
    
    // color7
    XM    = 0.001 ;
    XH    = 1.0 ;
    XJ    = 1.0 ;
    XR    = 0.0 ;

    // color8 
    XS1   = 0.3 ;
    QKS   = 0.2 ;
    XKUR  = 0.01 ;
    YKUR  = 1.00 ;

    // color9
    XTOF  = 0.02 ;  
    YTOF  = 0.80 ;  

    // output colors .....................................................
    ocolor6   = vec4(color6) ;
    ocolor7   = vec4(color7) ;
    ocolor8   = vec4(color8) ;
    ocolor9   = vec4(color9) ;
    return ;
}


</script><!-- end of init2 shader's source code -->

<!-- ***************************************************************** -->
<script id='comp1' type='x-shader-fragment'>#version 300 es
/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
 * comp1.frag 
 * ----------------
 * update colors 4-9 
 *
 * PROGRAMMER   :   ABOUZAR KABOUDIAN
 * DATE         :   Mon 01 Mar 2021 21:54:55 (EST)
 * PLACE        :   Chaos Lab @ GaTech, Atlanta, GA
 *@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
 */
precision highp float;
precision highp int ;
precision highp isampler2D ;
precision highp usampler2D ;


/*------------------------------------------------------------------------
 * Interface variables
 *------------------------------------------------------------------------
 */
in vec2 cc ;    // center coordinate of a pixel

// input samplers ........................................................
uniform sampler2D   icolor0 , icolor1 , icolor2 , icolor3 , icolor4 , 
                    icolor5 , icolor6 , icolor7 , icolor8 , icolor9 ;
uniform usampler2D  in_tinymtState , in_tinymtMat ;

/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 * uniforms
 *!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 */
uniform float dt ;  // time increment
uniform float lx ;  // domain length
uniform float diffCoef ; // diffusion coeficient


uniform int mx, my ; /* number of z-layers in S and T directions of the 
                        textures */

uniform usampler2D  idir0 ;
uniform usampler2D  idir1 ;
//
uniform sampler2D   compressed3dCrdt , full3dCrdt ;


// output colors .........................................................
layout (location = 0 ) out vec4     ocolor0 ;
layout (location = 1 ) out vec4     ocolor1 ;
layout (location = 2 ) out vec4     ocolor2 ;
layout (location = 3 ) out vec4     ocolor3 ;
layout (location = 4 ) out vec4     ocolor4 ;
layout (location = 5 ) out vec4     ocolor5 ;
layout (location = 6 ) out uvec4    out_tinymtState ;

// glsl shared files and functions .......................................
/*------------------------------------------------------------------------
 * total
 *------------------------------------------------------------------------
 */
#define bcal        24.0 
#define xkcal       7.0
#define srmax       47.0
#define srkd        0.6

// troponin 
#define Bt          70.0   
#define xkton       0.0327 
#define xktoff      0.0196
// xkton/xktoff
#define xktOnOff    (xkton/xktoff)
#define skx(ci)     ((ci)*Bt/((ci)+xktOnOff))

// calmodulin
#define bix(ci)     (bcal*(ci)/(xkcal+(ci)))

// SR buffering
#define six(ci)     (srmax*(ci)/(srkd+(ci)))

#define total(ci)   ((ci) + bix(ci) + six(ci))  /* skx(ci) */

/*------------------------------------------------------------------------
 * xfree
 *------------------------------------------------------------------------
 */
#define xx1(cit)  (104329.0-3126.0*(cit)+25.0*(cit)*(cit))
#define xfree(cit) (0.1*(-323.0+5.0*(cit)+sqrt(xx1(cit)))) 

/*------------------------------------------------------------------------
 * uptake
 *------------------------------------------------------------------------
 */
#define Ki      0.3
#define Knsr    800.0
#define HH      3.0
#define uptake(ci,vup) \
    (((vup)*(ci)*(ci)*(ci))/(Ki*Ki*Ki+(ci)*(ci)*(ci)))


/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 * tinymt.glsl  :   tiny mersene generator 
 *
 * PROGRAMMER   :   ABOUZAR KABOUDIAN
 * DATE         :   Tue 31 Mar 2020 14:25:32 (EDT)
 * PLACE        :   Chaos Lab @ GaTech, Atlanta, GA
 *!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 */

// global variables and the macros for the tinymt algorithm --------------
uvec4 tinymtState, tinymtMat ; 

#define TINYMT32_SH0    1
#define TINYMT32_SH1    10
#define TINYMT32_SH8    8
#define TINYMT32_MASK   uint(0x7fffffff)
#define MIN_LOOP        8
#define PRE_LOOP        8

#define MAX_INT         4294967295
#define MAX_INT_F       4294967295.

/*========================================================================
 * initTinyMt : initialize the Tiny Marsenne Twister for the shader
 *========================================================================
 */
void tinymtInit(){
    // Initialize the random number states 
    tinymtState = texture( in_tinymtState, cc ) ;
    tinymtMat   = texture( in_tinymtMat,   cc ) ;
    return ;
}

/*========================================================================
 * finish the tiny marsenne twister algorithm: should be called before the
 * shader return call ;
 *========================================================================
 */
void tinymtFinish(){
    out_tinymtState = uvec4(tinymtState) ;
    return ;
}
#define tinymtReturn  tinymtFinish

/*========================================================================
 * Iterate to the next state
 *========================================================================
 */
void tinymtNextState(){
    uint x,y ;
    y = tinymtState.a ;
    x = (tinymtState.r & TINYMT32_MASK)
        ^ tinymtState.g
        ^ tinymtState.b;
    x ^= (x << TINYMT32_SH0);
    y ^= (y >> TINYMT32_SH0) ^ x;
    tinymtState.r = tinymtState.g;
    tinymtState.g = tinymtState.b;
    tinymtState.b = x ^ (y << TINYMT32_SH1);
    tinymtState.a = y;
    tinymtState.g ^= uint(-int(y & uint(1)) & int(tinymtMat.r));
    tinymtState.b ^= uint(-int(y & uint(1)) & int(tinymtMat.g));

    return ;
}

/*========================================================================
 * temper the results
 *========================================================================
 */
uint  tinymtTemper() {
    uint t0, t1;
    t0 = tinymtState.a;
#if defined(LINEARITY_CHECK)
  t1 = tinymtState.r
      ^ (tinymtState.b >> TINYMT32_SH8);
#else
    t1 = tinymtState.r
        + (tinymtState.b >> TINYMT32_SH8);
#endif
    t0 ^= t1;
    t0 ^= uint(-int(t1 & uint(1)) & int(tinymtMat[2]));
    return t0;
}

/*========================================================================
 * Get a random number using the tiny marsenne twister 
 *========================================================================
 */
uint tinymtUrand(){
    tinymtNextState() ;
    return tinymtTemper() ;
}

/*========================================================================
 * tinymtFrand : returns a float number between 0-1 using the tiny mt
 * algorithm.
 *========================================================================
 */
float tinymtFrand(){
    return float(tinymtUrand())/MAX_INT_F ;
}
#define tinymtRand tinymtFrand

/*========================================================================
 * returns an integer with the binomial distribution with a Bernouli trail
 * of "npar" attempts with each attempt a chance of success of "p"
 *========================================================================
 */
uint tinymtBinran(float p, uint npar){
    uint isum = 0u ;
    if ( p > 0.1 ){
        for(uint i=0u ; i<npar ; i++){
            if ( tinymtRand() < p ){
                isum++ ;
            }
        }
    }else{ /* for small probablities of p use a geometric distribution */
        isum = uint( floor ( log( 1. - tinymtRand() ) /
                             log( 1. - p            )   ) ) ; 
    }
    return isum ;
}


/*========================================================================
 * variable mapping
 *========================================================================
 */
// color0: old4 
#define CB      color0.r
#define CI      color0.g
#define CSRB    color0.b
#define CSRI    color0.a

// color1: old5
#define CNSR    color1.r
#define PO      color1.g
#define C1      color1.b
#define C2      color1.a

// color2: old6 
#define XI1     color2.r
#define XI2     color2.g
#define XI1S    color2.b
#define XI2S    color2.a

// color3: old7
#define C1S     color3.r
#define C2S     color3.g
#define CIT     color3.b
#define CBT     color3.a

// color4: old8
#define PI      color4.r
#define PB      color4.g
#define POX     color4.b
#define POS     color4.a

/*  color5: old9
    Contains only integer values!
    We will implement as floats 
    for shading runtime reliablity. */
#define NSB     color5.r
#define NSI     color5.g
#define XINACA  color5.b
#define XICA    color5.a

//  color6: old0 
#define vchannel r
#define vlt_txtr icolor6
#define VLT     color6.r 
#define TIME    color6.g

// color7: old1
#define XM      color7.r
#define XH      color7.g
#define XJ      color7.b
#define XR      color7.a

// color8: old2 
#define XS1     color8.r
#define QKS     color8.g
#define XKUR    color8.b
#define YKUR    color8.a

// color9: old3 
#define XTOF    color9.r 
#define YTOF    color9.g

/*========================================================================
 * all direction macros go here for safe access
 *========================================================================
 */
#define NORTH   dir0.r
#define SOUTH   dir0.g
#define EAST    dir0.b
#define WEST    dir0.a

#define UP      dir1.r
#define DOWN    dir1.g

/*========================================================================
 * packing and unpacking two integers to and from a single unsigned int.
 *========================================================================
 */
#define pack(i,j)   uint((uint(i)<<16)+uint(j))
#define unpack(I)   ivec2(uint(I)>>16, uint(I) & uint(65535) )




/*========================================================================
 * macro functions
 *========================================================================
 */
#define  binevol(p,n) (( (n) > 0 ) ? \
        tinymtBinran( p, uint(n)) : 0u  )

#define binevolp(nt, nx, alpha, dt) \
        ( alpha < 0.00001 ) ? 0u : binevol(alpha*dt, nt-nx )

#define binevolm(nx,beta,dt)    binevol(beta*dt, nx )

/*========================================================================
 * main body of the shader
 *========================================================================
 */
void main(){
/*------------------------------------------------------------------------
 * Constant Parameters
 *------------------------------------------------------------------------
 */
    float xnai= 13.6 ; //-(600./250.)+16. ;
    float xnao=136.0 ;      // mM   ! external Na
    float xki=140.0;        // mM   ! internal K
    float xko=5.40 ;        // mM   ! external K
    float cao=1.8 ;         // mM   ! external Ca
    
    float temp=308.0;       // K    ! temperature
    float xxr=8.314;        //        
    float xf=96.485 ;       //      ! Faraday's constant
    float frt=xf/(xxr*temp) ;     

/*------------------------------------------------------------------------
 * Reading all state variables from textures
 *------------------------------------------------------------------------
 */
    // initialize tinymt states ..........................................
    tinymtInit() ; 

    // extract pixel values from textures ................................
    ivec2 isize = textureSize(icolor0,        0 ) ;
    ivec2 texelPos = ivec2( cc*vec2(isize) ) ; 

    vec4 color0 = texelFetch(icolor0 , texelPos, 0 ) ; 
    vec4 color1 = texelFetch(icolor1 , texelPos, 0 ) ; 
    vec4 color2 = texelFetch(icolor2 , texelPos, 0 ) ; 
    vec4 color3 = texelFetch(icolor3 , texelPos, 0 ) ; 
    vec4 color4 = texelFetch(icolor4 , texelPos, 0 ) ; 
    vec4 color5 = texelFetch(icolor5 , texelPos, 0 ) ; 
    vec4 color6 = texelFetch(icolor6 , texelPos, 0 ) ; 
    vec4 color7 = texelFetch(icolor7 , texelPos, 0 ) ; 
    vec4 color8 = texelFetch(icolor8 , texelPos, 0 ) ; 
    vec4 color9 = texelFetch(icolor9 , texelPos, 0 ) ; 

/*------------------------------------------------------------------------
 * localize voltage
 *------------------------------------------------------------------------
 */
    float v = VLT ;

/*------------------------------------------------------------------------
 * heterogeneity in the cable -- FIXME
 *------------------------------------------------------------------------
 */
    float gica, pbx ;
    gica = 3.0 ;
    
    pbx = 0.9 ;
   // if ( (cc.x > 0.3) && (cc.x<.5) ){
   //     pbx =0.45 ;
   // }else{
   //     pbx =0.8 ;
   // }

/*------------------------------------------------------------------------
 * volumes
 *------------------------------------------------------------------------
 */
    /* Use actual volumes */
    #define vi      1.   
    #define vb      0.3 
    #define vbi     (vb/vi)

    #define vq      30. 
    #define visr    vq 
    #define vsrin   ((1.0/visr)*vi)

    #define vbsr    vq
    
    #define vsrbound ((1.0/vbsr)*vb)

    #define vbisr   (vsrbound/vsrin)

    #define vnsr    vq 
    #define vnsrin  ((1.0/vnsr)*vi)

/*------------------------------------------------------------------------
 * Ca system 
 *------------------------------------------------------------------------
 */
    // convert total Ca to free ..........................................
    float ci = xfree(CIT) ;
    float cb = xfree(CBT) ;
    CI = ci ;
    CB = cb ;

    // fraction of clusters with sparks ----------------------------------
    #define nbt     2500. 
    #define nit     3000. 
    float pb  = NSB/nbt ;
    float pi  = NSI/nit ;

    PI = pi ;
    PB = pb ;

    #define vupb  0.2 
    #define vupi  0.25 

    float xupb = uptake(cb,vupb) ; // uptake at the boundary 
    float xupi = uptake(ci,vupi) ; // uptake at the interior sites

    // inaca -------------------------------------------------------------
    // >>>> THE CODE REPLACED inaca <<<<
    float cim=ci/1000.0; // ! convert to milli molars
      
    float zw3a=xnai*xnai*xnai*cao*exp(v*0.35*frt) ;
    float zw3b=xnao*xnao*xnao*cim*exp(v*(0.35-1.)*frt) ;

    float zw3=zw3a-zw3b ;
    float zw4=1.0+0.2*exp(v*(0.35-1.0)*frt) ;

    float xkdna=0.3 ; // ! micro M
    float aloss=1.0/(1.0+pow((xkdna/ci),3.)) ;

    float xmcao=1.3 ;
    float xmnao=87.5 ;
    float xmnai=12.3 ;
    float xmcai=0.0036 ;

    // Note: all concentrations are in mM

    float yz1=xmcao*xnai*xnai*xnai+xmnao*xmnao*xmnao*cim ;
    float yz2=xmnai*xmnai*xmnai*cao*(1.0+cim/xmcai) ;
    float yz3=
        xmcai*xnao*xnao*xnao*
            (1.0+(xnai/xmnai)*(xnai/xmnai)*(xnai/xmnai)) ;

    float yz4=xnai*xnai*xnai*cao+xnao*xnao*xnao*cim ;

    float zw8=yz1+yz2+yz3+yz4 ;

    float snaca=0.90 ; // ! exchanger strength 

    float xinacaq=snaca*aloss*zw3/(zw4*zw8) ;
    xinacaq *= 2.5 ;

    // ica ---------------------------------------------------------------
    float po  = PO ;
    float pos = POS ;
    float pox = po + pos ;

    POX = pox ;
    
    // >>>>> THE CODE REPLACED ica(...) <<<<<
    float pca=0.00054 ; // ! constant from Luo-Rudy
    float za=v*2.0*frt ;
    
    float factor1=4.0*pca*xf*frt ;
    float factor=v*factor1 ;

    //   compute driving force here 
    float rca ; 
    if(abs(za)<0.001){
        rca=factor1*(cim*exp(za)-0.341*(cao))/(2.0*frt) ;
    }else{
        rca=factor*(cim*exp(za)-0.341*(cao))/(exp(za)-1.0) ;
    }
    
    float xicaq=140.0*1.1*rca*pox ;
    xicaq=gica*xicaq ;

    // -------------------------------------------------------------------

    // Spark rate at the boundary 
    float ab=3.*20. ;
    float csrx=950.0 ;
    float csrb= CSRB ;
    float phisr=1.0/(1.0+pow((csrx/csrb),6.)) ; //cutoff rate bellow 500 muM

    float alphab=ab*abs(rca)*po*phisr ; // spark on rate due to LCC 
    float bts=1.0/20.0 ;                // spark off rate 

    float c1 = C1 ;
    float c2 = C2 ;
    
    float xi1 = XI1 ;
    float xi2 = XI2 ;
    float xi1s = XI1S ;
    float xi2s = XI2S ;
    
    float c1s = C1S ;
    float c2s = C2S ;

    // Markov chains .....................................................
    float a23=0.3 ;
    float a32=3.0 ;
    float a42=0.00224 ;
    
    float vth=0.0 ;

    //float s6=8.0 ;
    float s6=4.0 ;
    float poinf=1.0/(1.0+exp(-(v-vth)/s6)) ;
    float taupo=1.0 ;   
    //float taupo=2.0

    float a12=poinf/taupo ;
    float a21=(1.0-poinf)/taupo ;

    float vy=-40.0 ;
    float sy=4.0 ;
    float prv=1.0-1.0/(1.0+exp(-(v-vy)/sy)) ;

    float vyr=-40.0 ;
    float syr=10.0 ;
    float recov=10.0+4954.0*exp(v/15.6) ;
    float tauba=(recov-450.0)*prv+450.0 ;
    float poix=1.0/(1.0+exp(-(v-vyr)/syr)) ;

    float a15=poix/tauba ;
    float a51=(1.0-poix)/tauba ;

    float vx=-40.0; 
    float sx=3.0 ;
    float tau3=3.0 ;
    float poi=1.0/(1.0+exp(-(v-vx)/sx)) ;
    float a45=(1.0-poi)/tau3 ;
    
    // Ca dependent rates here ...........................................
    
    float cat=0.20 ;
    float zxr=0.06 ;
    float fca=1.0/(1.0+(cat/ci)*(cat/ci)) ;
    float a24=0.00413+zxr*fca ;
    float a34=0.00195+zxr*fca ;

    float a43=a34*(a23/a32)*(a42/a24) ;
    float a54=a45*(a51/a15)*(a24/a42)*(a12/a21) ;

    cat=1.0 ;
    float cp=150. ; //  high concentration here
    float fcax=1.0/(1.0+pow(cat/cp,2.)) ;
    float a24s=0.00413+zxr*fcax ;
    float a34s=0.00195+zxr*fcax ;

    float a43s=a34s*(a23/a32)*(a42/a24s) ;
    float a54s=a45*(a51/a15)*(a24s/a42)*(a12/a21) ;
    // state dynamics      

//c   alpha=0.
    
    float dpo= a23*c1+a43*xi1-(a34+a32)*po-alphab*po+bts*pos ;
    float dc2= a21*c1+a51*xi2-(a15+a12)*c2+bts*c2s ;
    float dc1= a12*c2+a42*xi1+a32*po-(a21+a23+a24)*c1+bts*c1s ;

    float dxi1=a24*c1+a54*xi2+a34*po-(a45+a42+a43)*xi1+bts*xi1s ;
//c   dxi2=a45*xi1+ a15*c2 -(a51+a54)*xi2+bts*xi2s

    float dpos= a23*c1s+a43s*xi1s-(a34s+a32)*pos+alphab*po-bts*pos; 
    float dc2s= a21*c1s+a51*xi2s-(a15+a12)*c2s-bts*c2s ;
    float dc1s= a12*c2s+a42*xi1s+a32*pos-(a21+a23+a24s)*c1s-bts*c1s ;

    float dxi1s=a24s*c1s+ a54s*xi2s+a34s*pos-(a45+a42+a43s)*xi1s-bts*xi1s
        ;
    float dxi2s=a45*xi1s+ a15*c2s -(a51+a54s)*xi2s-bts*xi2s ;

    PO = (po=po+dpo*dt) ;
    C1 = (c1=c1+dc1*dt) ;
    C2 = (c2=c2+dc2*dt) ;
    
    XI1 = (xi1=xi1+dxi1*dt) ;
//c   xi2=xi2+dxi2*dt

    POS = (pos=pos+dpos*dt) ;
    C1S = (c1s=c1s+dc1s*dt) ;
    C2S = (c2s=c2s+dc2s*dt) ;
    XI1S = (xi1s=xi1s+dxi1s*dt) ;
    XI2S = (xi2s=xi2s+dxi2s*dt) ;    

    XI2 = (xi2=1.0-c1-c2-po-xi1-pos-c1s-c2s-xi1s-xi2s) ;



    // >>>>>> end of markov <<<<<< .......................................
         
    float gsrb = 0.01/3.0 ;
    float xryrb = gsrb*csrb*pb ;
    
    // spark rate in the interior ........................................
    float gi =0.01/2.5 ;
    float csrxx = 900.0 ;
    float csri = CSRI ;
    float phi=1. / (1.+(csrxx / pow(csri,8.))) ;

    float pra=0.05 ; // ! increase threshold here
    float xra=pow( pra / PI,5.) ;
    float ra_inf=1.0/(1.0+xra) ;

    float rr=0.007 ;
//c       pbx=0.45  ! very nice alternans
//c       pbx=0.5
        
    float pbinf=1.0/(1.0+pow(pbx/pb,10.)) ;

    float alphai=(rr*pbinf+gi*ra_inf)*phi ; //! spontaneous spark rate in the interior
//
    float gryri=0.012 ;
    float xryri=gryri*pi*csri ;

    float btsi=1./40. ;

    float xsarc=-xicaq+xinacaq ;
        
    float tausri=50. ;
    float cnsr = CNSR ;
    float dff=(cnsr-csri)/tausri ;

    float tau1=10. ;
    float tau2=10. ;

    float dfbi=1.0*(cb-ci)/tau1 ;
    float dfbisr=1.0*(csrb-cnsr)/tau2 ;

    float dcbt=xryrb-xupb+xsarc-dfbi ;
    float dcsrb=vbsr*(-xryrb+xupb)-dfbisr ;

    float dcit=xryri-xupi+vbi*dfbi  ;               
    float dcsri=visr*(-xryri)+dff ;
  
    float dnsr=vnsr*(xupi)-dff+vbisr*dfbisr ;

    float cbt = (CBT += dcbt*dt) ;
    float cit = (CIT += dcit*dt) ;
    
    CSRB = (csrb += dcsrb*dt) ;        
    CSRI = (csri += dcsri*dt) ;

    CNSR = (cnsr+=dnsr*dt) ;

    // time evolution due to binomial distribution .......................
    float nsb  = NSB ;

    // >>>> in place of 
    // call binevol(nbt,nsbx,alphab,bts,dt,iseed,ndeltapx,ndeltamx) <<<<<<
    
    float ndeltapx = float (binevolp( int(nbt) , int(nsb), alphab , dt));
    float ndeltamx = float (binevolm( int(nsb), bts, dt ) );

    if (ndeltamx > nsb || ndeltapx > nbt ){
        nsb = 0. ;
    }else{
        nsb = nsb + ndeltapx - ndeltamx ;
    } 
    NSB = nsb ; // updating nsb
    
    /* call binevol(nit,nsix,alphai,btsi,dt,iseed,ndeltapy,ndeltamy) */
    float nsi = NSI ;

    float ndeltapy = float(binevolp( int(nit), int(nsi),alphai, dt ) );
    float ndeltamy = float(binevolm( int(nsi), btsi, dt ) ) ; 

    if ( ndeltamy > nsi || ndeltapy > nit ){
        nsi = 0. ;
    }else{
        nsi = nsi + ndeltapy - ndeltamy ;
    }
    NSI = nsi ; // updating nsi 

    // xinaca and xica
    float wca=10. ;
    float xinaca=wca*xinacaq ; // ! convert ion flow to current
    float xica=2.0*wca*xicaq ;

    XINACA = xinaca;
    XICA   = xica  ;
/*------------------------------------------------------------------------
 * output calculated and updated color values 
 *------------------------------------------------------------------------
 */
    ocolor0 = vec4(color0) ;
    ocolor1 = vec4(color1) ;
    ocolor2 = vec4(color2) ;
    ocolor3 = vec4(color3) ;
    ocolor4 = vec4(color4) ;
    ocolor5 = vec4(color5) ;

    // return tinymt states ..............................................
    tinymtReturn() ;
    return ;
}


</script><!-- end of comp1 shader's source code -->

<!-- ***************************************************************** -->
<script id='comp2' type='x-shader-fragment'>#version 300 es
/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
 * comp2.frag
 * ----------------
 * update colors 0-4
 *
 * PROGRAMMER   :   ABOUZAR KABOUDIAN
 * DATE         :   Mon 01 Mar 2021 21:55:27 (EST)
 * PLACE        :   Chaos Lab @ GaTech, Atlanta, GA
 *@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
 */
precision highp float;
precision highp int ;
precision highp isampler2D ;
precision highp usampler2D ;


in vec2 cc ;

/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 * uniforms
 *!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 */
uniform float dt ;  // time increment
uniform float lx ;  // domain length
uniform float diffCoef ; // diffusion coeficient


uniform int mx, my ; /* number of z-layers in S and T directions of the 
                        textures */

uniform usampler2D  idir0 ;
uniform usampler2D  idir1 ;
//
uniform sampler2D   compressed3dCrdt , full3dCrdt ;


// uniform samplers ......................................................
uniform sampler2D   icolor0 , icolor1 , icolor2 , icolor3 , icolor4 , 
                    icolor5 , icolor6 , icolor7 , icolor8 , icolor9 ;
/*------------------------------------------------------------------------
 * ouput colors
 *------------------------------------------------------------------------
 */
layout (location = 0 ) out vec4     ocolor6 ;
layout (location = 1 ) out vec4     ocolor7 ;
layout (location = 2 ) out vec4     ocolor8 ;
layout (location = 3 ) out vec4     ocolor9 ;

/*========================================================================
 * variable mapping
 *========================================================================
 */
// color0: old4 
#define CB      color0.r
#define CI      color0.g
#define CSRB    color0.b
#define CSRI    color0.a

// color1: old5
#define CNSR    color1.r
#define PO      color1.g
#define C1      color1.b
#define C2      color1.a

// color2: old6 
#define XI1     color2.r
#define XI2     color2.g
#define XI1S    color2.b
#define XI2S    color2.a

// color3: old7
#define C1S     color3.r
#define C2S     color3.g
#define CIT     color3.b
#define CBT     color3.a

// color4: old8
#define PI      color4.r
#define PB      color4.g
#define POX     color4.b
#define POS     color4.a

/*  color5: old9
    Contains only integer values!
    We will implement as floats 
    for shading runtime reliablity. */
#define NSB     color5.r
#define NSI     color5.g
#define XINACA  color5.b
#define XICA    color5.a

//  color6: old0 
#define vchannel r
#define vlt_txtr icolor6
#define VLT     color6.r 
#define TIME    color6.g

// color7: old1
#define XM      color7.r
#define XH      color7.g
#define XJ      color7.b
#define XR      color7.a

// color8: old2 
#define XS1     color8.r
#define QKS     color8.g
#define XKUR    color8.b
#define YKUR    color8.a

// color9: old3 
#define XTOF    color9.r 
#define YTOF    color9.g

/*========================================================================
 * all direction macros go here for safe access
 *========================================================================
 */
#define NORTH   dir0.r
#define SOUTH   dir0.g
#define EAST    dir0.b
#define WEST    dir0.a

#define UP      dir1.r
#define DOWN    dir1.g

/*========================================================================
 * packing and unpacking two integers to and from a single unsigned int.
 *========================================================================
 */
#define pack(i,j)   uint((uint(i)<<16)+uint(j))
#define unpack(I)   ivec2(uint(I)>>16, uint(I) & uint(65535) )




/*========================================================================
 * main body of the shader
 *========================================================================
 */
void main(){
    
    // extract pixel values from textures ................................
    ivec2 isize = textureSize(icolor0,        0 ) ;
    ivec2 texelPos = ivec2( cc*vec2(isize) ) ; 

    vec4 color0 = texelFetch(icolor0 , texelPos, 0 ) ; 
    vec4 color1 = texelFetch(icolor1 , texelPos, 0 ) ; 
    vec4 color2 = texelFetch(icolor2 , texelPos, 0 ) ; 
    vec4 color3 = texelFetch(icolor3 , texelPos, 0 ) ; 
    vec4 color4 = texelFetch(icolor4 , texelPos, 0 ) ; 
    vec4 color5 = texelFetch(icolor5 , texelPos, 0 ) ; 
    vec4 color6 = texelFetch(icolor6 , texelPos, 0 ) ; 
    vec4 color7 = texelFetch(icolor7 , texelPos, 0 ) ; 
    vec4 color8 = texelFetch(icolor8 , texelPos, 0 ) ; 
    vec4 color9 = texelFetch(icolor9 , texelPos, 0 ) ; 

    uvec4 dir0  = texelFetch(idir0 , texelPos, 0 ) ;
    uvec4 dir1  = texelFetch(idir1 , texelPos, 0 ) ;

    vec3  crdt  = texelFetch(compressed3dCrdt, texelPos, 0 ).xyz ; 

    // extracting individual variables from colors .......................
    // txtr0
    float v = VLT ;
    float time = TIME ;

    // txtr1                     // txtr2
    float xm    = XM ;          float xs1   = XS1   ;
    float xh    = XH ;          float qks   = QKS   ;
    float xj    = XJ ;          float xkur  = XKUR  ;
    float xr    = XR ;          float ykur  = YKUR  ;

    // txtr3 
    float xtof  = XTOF  ;
    float ytof  = YTOF  ;
    
    // txtr4                    // txtr5 
    float cb    = CB   ;        float cnsr = CNSR ;
    float ci    = CI   ;        float po   = PO   ;
    float csrb  = CSRB ;        float c1   = C1   ;
    float csri  = CSRI ;        float c2   = C2   ;
    
    // txtr6                    // txtr7 
    float xi1  = XI1  ;         float c1s = C1S ;
    float xi2  = XI2  ;         float c2s = C2S ;
    float xi1s = XI1S ;         float cit = CIT ;
    float xi2s = XI2S ;         float cbt = CBT ;
    
    // txtr8                    // txtr9 
    float pi   = PI   ;         float nsb = NSB ;
    float pb   = PB   ;         float nsi = NSI ;
    float pox  = POX  ;         float xinaca = XINACA ;
    float pos  = POS  ;         float xica = XICA ;

    // constant parameters ...............................................
    float xnai= 16.6 ; //-(600./250.)+16. ;
    float xnao=136.0 ; // !;mM   ! external Na
    float xki=140.0 ; // !; mM   ! internal K
    float xko=5.40 ; //  !;mM    ! external K
    float cao=1.8 ; //  !;mM     ! external Ca
        
    float temp=308.0 ; //        ! temperature (K)
    float xxr=8.314 ; //         
    float xf=96.485 ; //         ! Faraday's constant
    float frt=xf/(xxr*temp)   ;    
    
    // FIXME no adaptive time update yet .................................
    float hode = dt ; 

    // ina ...............................................................
    float gna=10.0 ; //
    float XKMCAM=0.3; // 
    float deltax=-0.18 ; // 
    
    float ena = (1.0/frt)*log(xnao/xnai) ; // ! sodium reversal potential
    
    float am ;
    if ( abs(v+47.13) > 0.1 ){
        am = 0.32*(v+47.13)/(1.0-exp(-0.1*(v+47.13))) ;
    }else{
        am = 3.2 ;
    }

    float bm = 0.08*exp(-v/11.0) ;

//   float  camfact= 1.0/(1.0+pow((XKMCAM/caM),4.)) ;
//   float  vshift = -3.25*camfact ;

    float camfact=0. ;
    float vshift=0. ;
    
    float vx=v-vshift ;

    float ah, bh, aj,bj, bja ;
    if(vx < (-40.0)){
        ah=0.135*exp((80.0+vx)/(-6.8)) ;
        bh=3.56*exp(0.079*vx)+310000.0*exp(0.35*vx) ;

        float aj1a=-127140.0*exp(0.2444*vx) ;
        float aj1b=0.00003474*exp(-0.04391*vx) ;
        float aj1c=(vx+37.78)/(1.0+exp(0.311*(vx+79.23))) ;

        aj=(1.0+camfact*deltax)*(aj1a-aj1b)*aj1c ;
        bj=(0.1212*exp(-0.01052*vx))/(1.0+exp(-0.1378*(vx+40.14))) ;
    }else{
        ah=0.0 ;
        bh=1.0/(0.13*(1.0+exp((vx+10.66)/(-11.1)))) ;
        aj=0.0 ;

        float bja=0.3*exp(-0.0000002535*vx) ;
        float bjb=1.0+exp(-0.1*(vx+32.0)) ;

        bj=bja/bjb ;
    }          
    
    float tauh=1.0/(ah+bh) ;  
    float tauj=1.0/(aj+bj) ;
    float taum=1.0/(am+bm) ;
 
    float xina=gna*xh*xj*xm*xm*xm*(v-ena) ;

    xh = ah/(ah+bh)-((ah/(ah+bh))-xh)*exp(-hode/tauh) ;
    xj = aj/(aj+bj)-((aj/(aj+bj))-xj)*exp(-hode/tauj) ;
    xm = am/(am+bm)-((am/(am+bm))-xm)*exp(-hode/taum) ;
    
    // updating the color channels
    XH = xh ;
    XJ = xj ;
    XM = xm ;

    // ikr ...............................................................
    float ek = (1.0/frt)*log(xko/xki) ; // ! K reversal potential
    
    float gss=sqrt(xko/5.40) ;
    float xkrv1, xkrv2 ;

    if (abs(v+7.0)>.1){
        xkrv1=0.00138*(v+7.0)/( 1.-exp(-0.123*(v+7.0))  ) ;
    }else{
        xkrv1=0.00138/0.123 ;
    }

    if ( abs(v+10.)>.1 ){
        xkrv2=0.00061*(v+10.0)/(exp( 0.145*(v+10.0))-1.0) ;
    }else{
        xkrv2=0.00061/(0.145) ;
    }

    float taukr=1.0/(xkrv1+xkrv2) ;

    float xkrinf=1.0/(1.0+exp(-(v+50.0)/7.5)) ;

    float rg=1.0/(1.0+exp((v+33.0)/22.4)) ;
          
    float gkr=0.007836 ; //! Ikr conductance 
    float xikr=gkr*gss*xr*rg*(v-ek) ;

    xr=xkrinf-(xkrinf-xr)*exp(-hode/taukr) ;
    
    // updating the color channels
    XR = xr ;

    // iks ...............................................................
    float prnak=0.018330 ;

    float qks_inf=0.6*ci ;
    float tauqks=1000.0 ;

    float eks=(1.0/frt)*log((xko+prnak*xnao)/(xki+prnak*xnai)) ;
    float xs1ss=1.0/(1.0+exp(-(v-1.50)/16.70)) ;
    float xs2ss=xs1ss ;

    float tauxs ;
    if ( abs(v+30.) > .1){
        tauxs=1.0/(0.0000719*(v+30.0)/(1.0-exp(
                    -0.148*(v+30.0)))+0.000131
            *(v+30.0)/(exp(0.0687*(v+30.0))-1.0)) ;
    }else{
        tauxs = 413.5711 + 5.1618*(v+30.) ;
    }

    float gksx=0.200 ;// ! Iks conductance 
    float xiks=gksx*qks*xs1*xs1*(v-eks) ;

    xs1=xs1ss-(xs1ss-xs1)*exp(-hode/tauxs);
    qks=qks+hode*(qks_inf-qks)/tauqks;
    
    // updating the color channels
    XS1 = xs1;
    QKS = qks;

    // ik1 ...............................................................
    float gkix=0.60*0.6 ; // ! Ik1 conductance reduced in Grandi model
    float gki=gkix*(sqrt(xko/5.4)) ;
    float aki=1.02/(1.0+exp(0.2385*(v-ek-59.215))) ;
    float bki=(0.49124*exp(0.08032*(v-ek+5.476))
            +   exp(0.061750*(v-ek-594.31)))/
        (1.0+exp(-0.5143*(v-ek+4.753))) ;
    float xkin=aki/(aki+bki) ;
    float xik1=gki*xkin*(v-ek) ;

    // ikur ..............................................................
    // float  Gkur=0.08 ;
    float Gkur=0.04; 
    // float  Gkur = 0.045*1.5 ;

    float rh1=(v+6.)/(-8.6) ;
    float xkurss=1./(1.+exp(rh1)) ;
    float tauxkur=9.0/(1.+exp((v+5.0)/12.0))+0.5 ;

    float ykurss  =1.0/(1.0+exp((v+7.5)/10.0)) ;
    float tauykur = 590.0/(1.+exp((v+60.)/10.0))+3050.0 ;

    xkur = xkurss-(xkurss-xkur)*exp(-hode/tauxkur) ;
    ykur = ykurss-(ykurss-ykur)*exp(-hode/tauykur) ;

    float xikur = Gkur*xkur*ykur*(v-ek) ;

    // updating the color channels
    XKUR  = xkur ;
    YKUR  = ykur ;

    // ito ...............................................................
    float gtof=0.01/1.5 ;

    float rg1=-(v+1.0)/11.0 ; 
    float xtof_inf=1./(1.+exp(rg1)) ;

    float rg3=-(v/30.)*(v/30.) ;
    float txf=3.5*exp(rg3)+1.5 ;

    float rg2=(v+40.5)/11.5 ;
    float ytof_inf=1.0/(1.+exp(rg2)) ;

    float rg4=-((v+52.45)/15.8827)*((v+52.45)/15.8827) ;
    float tyf=25.635*exp(rg4)+24.14 ;

    float xitof=gtof*xtof*ytof*(v-ek) ;

    xtof = xtof_inf-(xtof_inf-xtof)*exp(-hode/txf) ;
    ytof = ytof_inf-(ytof_inf-ytof)*exp(-hode/tyf) ;

    float xito=xitof ;// ! total ito current (itos removed in Grandi)
    
    XTOF  = xtof ; 
    YTOF  = ytof ; 

    // inak ..............................................................
    float xkmko=1.5  ; //! these are Inak constants adjusted to fit
    //c     ! the experimentally measured dynamic restitution curve
    float xkmnai=12.0 ;
    float xibarnak=1.50 ; 
    float hh=1.0  ; //! Na dependence exponent

    float sigma = (exp(xnao/67.3)-1.0)/7.0  ;
    float fnak = 1.0/(1.+0.1245*exp(-0.1*v*frt)
            +0.0365*sigma*exp(-v*frt)) ;
    float xinak = xibarnak*fnak*(1./(1.+xkmnai/xnai))*xko/(xko+xkmko) ;
    
    float xsum = (
           xina
        +  xik1
        +  xikr
        +  xiks
        +  xito
        +  xikur
        +  xinaca
        +  xica
        +  xinak
    ) ;

    // laplacian .........................................................

    float  dx = 10./128. ;

    float laplacian = (
            texelFetch( vlt_txtr, unpack( NORTH ), 0 )
        +   texelFetch( vlt_txtr, unpack( SOUTH ), 0 )
        +   texelFetch( vlt_txtr, unpack( EAST  ), 0 )
        +   texelFetch( vlt_txtr, unpack( WEST  ), 0 )
        +   texelFetch( vlt_txtr, unpack( UP    ), 0 )
        +   texelFetch( vlt_txtr, unpack( DOWN  ), 0 )
        -6.*texelFetch( vlt_txtr, texelPos, 0 )         ).vchannel ;

    laplacian = diffCoef*laplacian/(dx*dx) ;

    VLT += (laplacian - xsum )*dt ;
    TIME += dt ;

    if ( abs(int(TIME)%400) <1 ){
       // if ( length(crdt)<0.5)
            VLT = 30. ;
    }

    // return updated states .............................................
    ocolor6  = vec4(color6) ;
    ocolor7  = vec4(color7) ;
    ocolor8  = vec4(color8) ;
    ocolor9  = vec4(color9) ;
    return ;
}


</script><!-- end of comp2 shader's source code -->

<!-- ***************************************************************** -->
<script id='fullCoordinator' type='x-shader-fragment'>#version 300 es
/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
 * crdtShader   :   calculates the coordinate of each point in 3d
 *
 * PROGRAMMER   :   ABOUZAR KABOUDIAN
 * DATE         :   Mon 14 Aug 2017 10:35:08 AM EDT
 * PLACE        :   Chaos Lab @ GaTech, Atlanta, GA
 *@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
 */
precision highp float;
precision highp int ;
precision highp isampler2D ;
precision highp usampler2D ;


/*------------------------------------------------------------------------
 * Interface Vars.
 *------------------------------------------------------------------------
 */
in      vec2        pixPos ;
uniform float       mx, my ;

/*------------------------------------------------------------------------
 * Output
 *------------------------------------------------------------------------
 */
layout (location = 0 ) out vec4  crdt ;

/*========================================================================
 * main body 
 *========================================================================
 */
void main(){
    crdt = vec4(1.0) ;

    crdt.x = (pixPos.x - floor(pixPos.x * mx)/mx ) * mx ;
    crdt.y = (pixPos.y - floor(pixPos.y * my)/my ) * my ;

    float sliceNo = floor(pixPos.x * mx) 
                +   ( ( my-1.0) - floor(pixPos.y * my) )*mx ;

    crdt.z = sliceNo/(mx*my) ;
    return ;
}


</script><!-- end of fullCoordinator shader's source code -->

<!-- ***************************************************************** -->
<script id='compressedCoordinator' type='x-shader-fragment'>#version 300 es
/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
 * compressedCoordinator : calculate the 3d coordinate on the compressed
 * structure.
 *
 * PROGRAMMER   : ABOUZAR KABOUDIAN
 * DATE         : Sat 06 Mar 2021 18:15:05 (EST)
 * PLACE        : Chaos Lab @ GaTech, Atlanta, GA
 *@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
 */
precision highp float;
precision highp int ;
precision highp isampler2D ;
precision highp usampler2D ;


/*------------------------------------------------------------------------
 * interface variables
 *------------------------------------------------------------------------
 */
in vec2 cc ;
uniform sampler2D   full3dCrdt ;
uniform usampler2D  fullTexelIndex ;

out vec4 compressed3dCrdt ;

/*========================================================================
 * main body of the shader
 *========================================================================
 */
void main(){
    // calculate the current texels position
    ivec2 texelPos = ivec2(cc*vec2(textureSize( fullTexelIndex, 0 ))) ;

    // index of the current texel in the full domain
    ivec4 fullTexelIndex = ivec4(
        texelFetch( fullTexelIndex, texelPos, 0)
    ) ;

    if ( fullTexelIndex.a == 1){
        // extract the coorinate of the point from the full3dCrdt 
        compressed3dCrdt = texelFetch( full3dCrdt, fullTexelIndex.xy, 0 ) ;
        return ;
    }else{
        // value for extra-no domain points
        compressed3dCrdt = vec4(-1.) ;
        return ;
    }
}


</script><!-- end of compressedCoordinator shader's source code -->

<!-- ***************************************************************** -->
<script id='directionator' type='x-shader-fragment'>#version 300 es
/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
 * directionator.frag : find North, South, East, West, Up and Down
 * dirction indices 
 *
 * PROGRAMMER   : ABOUZAR KABOUDIAN
 * DATE         : Sat 06 Mar 2021 21:02:53 (EST)
 * PLACE        : Chaos Lab @ GaTech, Atlanta, GA
 *@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
 */
precision highp float;
precision highp int ;
precision highp isampler2D ;
precision highp usampler2D ;

/*========================================================================
 * packing and unpacking two integers to and from a single unsigned int.
 *========================================================================
 */
#define pack(i,j)   uint((uint(i)<<16)+uint(j))
#define unpack(I)   ivec2(uint(I)>>16, uint(I) & uint(65535) )

/*========================================================================
 * all direction macros go here for safe access
 *========================================================================
 */
#define NORTH   dir0.r
#define SOUTH   dir0.g
#define EAST    dir0.b
#define WEST    dir0.a

#define UP      dir1.r
#define DOWN    dir1.g

/*========================================================================
 * packing and unpacking two integers to and from a single unsigned int.
 *========================================================================
 */
#define pack(i,j)   uint((uint(i)<<16)+uint(j))
#define unpack(I)   ivec2(uint(I)>>16, uint(I) & uint(65535) )


/*-------------------------------------------------------------------------
 * interfacial variables
 *-------------------------------------------------------------------------
 */
in vec2 cc ;

uniform usampler2D fullTexelIndex, compressedTexelIndex ;
uniform int mx, my ;

/*------------------------------------------------------------------------
 * output colors
 *------------------------------------------------------------------------
 */
layout (location = 0) out uvec4 odir0 ;
layout (location = 1) out uvec4 odir1 ;

/*========================================================================
 * getIJ: return the IJ index on the full 2d-matrix
 *========================================================================
 */
ivec2 getIJ(ivec3 idx, ivec3 size){
    int si = idx.z % mx ;
    int sj = idx.z / mx ;

    return ivec2(size.x*si + idx.x, (my-1-sj)*size.y + idx.y) ;
}

/*========================================================================
 * getIdx: get the 3d index from the IJ indices
 *========================================================================
 */
ivec3 getIdx( ivec2 IJ, ivec3 size ){
    int si = IJ.x / size.x ;
    int sj = (my - 1) - (IJ.y/size.y) ;

    return ivec3( IJ.x % size.x, IJ.y % size.y , mx*sj + si ) ;
}

/*========================================================================
 * macros 
 *========================================================================
 */
#define isInBounds( v )     (all(greaterThanEqual(v,ivec3(0))) && \
        all(lessThan(v,size)))

#define texelInDomain(I)  ( texelFetch(compressedTexelIndex,(I),\
            0).a==uint(1) )
#define inDomain( v )   (texelInDomain( getIJ(v, size) )) 
#define isNotGood(v)   (!( inDomain(v) && isInBounds( v ) ))

/*========================================================================
 * getPackedIndex: get packed index of the point by applying the zero-flux
 * condition.
 *========================================================================
 */
uint getPackedIndex( ivec3 C, ivec3 D, ivec3 size ){
    ivec3 checkPoint = C+D ;
    
    if ( isNotGood(checkPoint) ){ /* if that direction is not good move in
                                     the opposite direction */
        checkPoint = C-D ;
        if ( isNotGood( checkPoint ) ){ /* if the opposite direction is
                                           not good either, use the
                                           central point coordinate */
            checkPoint = C ;
        }
    }
    uvec2 targetIndex = texelFetch(
            compressedTexelIndex,
            getIJ(checkPoint,size),
            0 ).xy ;
    return pack(targetIndex.x,targetIndex.y) ;  
}

/*========================================================================
 * main
 *========================================================================
 */
void main(){
    // get the sizes of the compressed and the full domain ...............
    ivec2 compSize = textureSize(fullTexelIndex,        0 ) ;
    ivec2 fullSize = textureSize(compressedTexelIndex,  0 ) ;

    // calculate the resolution of the full domain .......................
    ivec3 size = ivec3( fullSize.x/mx , fullSize.y/my, mx*my ) ;

    // get the textel position and full texel index ......................
    ivec2 texelPos = ivec2( cc*vec2(compSize) ) ; 
    ivec4 fullTexelIndex = 
        ivec4( texelFetch(  fullTexelIndex, texelPos, 0) ) ;

    // if the texel is extra, just leave .................................
    if ( fullTexelIndex.a != 1 ){
        return ;
    }
    
    // 3-dimentional index of the of texel ...............................
    ivec3 cidx = getIdx( fullTexelIndex.xy , size ) ;

    // diretionional vectors .............................................
    ivec3 ii = ivec3(1,0,0) ;
    ivec3 jj = ivec3(0,1,0) ;
    ivec3 kk = ivec3(0,0,1) ;

    // calculating the packed indices of the each compute point ..........
    uvec4 dir0 , dir1 ;
   
    NORTH = getPackedIndex( cidx, jj, size) ; // north direction
    SOUTH = getPackedIndex( cidx,-jj, size) ; // south direction
    EAST  = getPackedIndex( cidx, ii, size) ; // east  direction
    WEST  = getPackedIndex( cidx,-ii, size) ; // west  direction

    UP    = getPackedIndex( cidx, kk, size) ; // up   direction
    DOWN  = getPackedIndex( cidx,-kk, size) ; // down direction

    // outputing the calculated points ...................................
    odir0 = uvec4(dir0) ;
    odir1 = uvec4(dir1) ;

    return ;
}


</script><!-- end of directionator shader's source code -->


<!--&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&-->
<!-- main script - JavaScript code                                     -->
<!--&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&-->
<script>
/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
 * WEBGL 2.0    :   Shiferaw Model 
 *
 * PROGRAMMER   :   ABOUZAR KABOUDIAN
 * DATE         :   Mon 01 Mar 2021 22:05:37 (EST)
 * PLACE        :   Chaos Lab @ GaTech, Atlanta, GA
 *@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
 */
"use strict" ;

/*========================================================================
 * get the source code for fragment shaders
 *========================================================================
 */
function source( id ){
    return document.getElementById( id ).innerHTML ;
}
/*========================================================================
 * Global Parameters
 *========================================================================
 */
var env = {} ;

/*========================================================================
 * Initialization of the GPU and Container
 *========================================================================
 */
function loadWebGL()
{
/*------------------------------------------------------------------------
 * defining the environments initial values 
 *------------------------------------------------------------------------
 */
    env.running     = false ;
    env.dt          = 0.1 ;
    env.diffCoef    = 0.001 ;
    env.C_m         = 1. ;
    env.lx          = 5  ;
    env.skip        = 10 ;
    env.time        = 0. ;

    
    env.allFloats   = ['dt','diffCoef', 'lx' ] ; // uniform shared floats
    env.allInts     = [] ; // uniform shared integers
    env.allTxtrs    = [] ; // uniform shared textures
   
    // solver parameteres ................................................
    //env.width       = 256 ;
    //env.height      = 256 ;

    // display prameters .................................................
    env.colormap    = 'rainbowHotSpring' ;
    env.dispWidth   = 512 ;
    env.dispHeight  = 512 ;

    env.canvas_1 = document.getElementById("canvas_1") ;
    env.canvas_2 = document.getElementById("canvas_2") ;
    env.canvas_1.width  = env.dispWidth ;
    env.canvas_1.height = env.dispHeight ;

/*------------------------------------------------------------------------
 * load the structure and process it
 *------------------------------------------------------------------------
 */
    env.mx = 16 ;
    env.my = 8 ;

    env.allInts = [...env.allInts, 'mx','my' ] ;

    env.structure = document.getElementById('structure') ;
    
    console.log('Compressing structure...') ;

    env.sparsePhase = new Abubu.SparseDataFromImage(env.structure, 
            { channel : 'r', threshold : 0.01 } ) ;
    console.log('Done!') ;
    console.log('Compression ratio :', 
            env.sparsePhase.getCompressionRatio() ) ;

    env.fphaseTxt   = env.sparsePhase.full  ;
    env.cphaseTxt   = env.sparsePhase.sparse ;
    env.compMap     = env.sparsePhase.compressionMap ;
    env.dcmpMap     = env.sparsePhase.decompressionMap ;

    env.fullTexelIndex = env.sparsePhase.fullTexelIndex ;
    env.compressedTexelIndex = env.sparsePhase.compressedTexelIndex ;

    env.width       = env.cphaseTxt.width ;
    env.height      = env.cphaseTxt.height ;
    env.fwidth      = env.fphaseTxt.width ;      /* full-width   */
    env.fheight     = env.fphaseTxt.height ;     /* full-height  */

/*-------------------------------------------------------------------------
 * coordinate texture (full) 
 *-------------------------------------------------------------------------
 */
    env.full3dCrdt  = new Abubu.Float32Texture(
            env.fwidth,
            env.fheight
    ) ;
    
    env.fullCoordinator = new Abubu.Solver({
        fragmentShader: source('fullCoordinator') ,
        uniforms : { 
            mx : { type : 'f' , value : env.mx } ,
            my : { type : 'f' , value : env.my } ,
        } ,
        targets : { 
            crdt : { location : 0, target : env.full3dCrdt } ,
        }
    } ) ;
    env.fullCoordinator.render() ;

/*------------------------------------------------------------------------
 * compressedCoordinate
 *------------------------------------------------------------------------
 */
    env.compressed3dCrdt  = new Abubu.Float32Texture( 
            env.width, env.height ) ;

    env.compressedCoordinator = new Abubu.Solver({
        fragmentShader: source('compressedCoordinator') ,
        uniforms : { 
            fullTexelIndex : { type : 't', value : env.fullTexelIndex } ,
            full3dCrdt : { type : 't', value : env.full3dCrdt } ,
        } ,
        targets : { 
            compressed3dCrdt : { 
                location : 0, target : env.compressed3dCrdt 
            } ,
        }
    } ) ;

    env.compressedCoordinator.render() ;

    env.allTxtrs = [...env.allTxtrs, 'compressed3dCrdt' ] ;  
/*------------------------------------------------------------------------
 * zero-flux directionator 
 *------------------------------------------------------------------------
 */
    env.dir0 = new Abubu.Uint32Texture( env.width, env.height ) ;
    env.dir1 = new Abubu.Uint32Texture( env.width, env.height ) ;

    env.idir0 = env.dir0 ;
    env.idir1 = env.dir1 ;

    env.directionator = new Abubu.Solver({
        fragmentShader : source('directionator') ,
        uniforms : {
            mx : { type : 'i' , value : env.mx } ,
            my : { type : 'i' , value : env.my } ,
            fullTexelIndex : { 
                type : 't', value : env.fullTexelIndex 
            } ,
            compressedTexelIndex : { 
                type : 't', value : env.compressedTexelIndex
            } ,
        },
        targets: {
            odir0 : { location : 0, target : env.dir0 } ,
            odir1 : { location : 1, target : env.dir1 } ,
        }
    } ) ;
    env.directionator.render() ; 

    env.allTxtrs = [...env.allTxtrs, 'idir0', 'idir1' ] ;

/*------------------------------------------------------------------------
 * state variables for the psuedo-random generator
 *------------------------------------------------------------------------
 */
    // states for the random generator ...................................
    env.istate  = new Uint32Array(env.width*env.height*4) ;
    env.imat    = new Uint32Array(env.width*env.height*4) ;

    // preparing the initial states for each pixel .......................
    var p=0 ;
    var seed = 0 ;
    var tm = new Abubu.TinyMT({vmat: 0}) ;

    for(var j=0 ; j<env.height ; j++){
        for(var i=0 ; i<env.width ; i++){
            //  mat1            mat2            seed 
            tm.mat[0] = i ;     tm.mat[1] = j ; tm.mat[3] = seed ;
            tm.init() ;

            for(var k=0 ; k<4 ; k++){
                env.istate[p] = tm.state[k] ;  
                env.imat[p] = tm.mat[k] ;  
                p++ ;
            }
        }
    }

    // first time-step random textures ...................................
    env.ftinymtState = new Abubu.Uint32Texture( env.width, env.height ,
            {data : env.istate ,pair : true } ) ;
    env.stinymtState = new Abubu.Uint32Texture( env.width, env.height ,
            {data : env.istate ,pair : true } ) ;
    
    // mat state for each point of the generator .........................
    env.tinymtMat = new Abubu.Uint32Texture( env.width, env.height ,
            {data : env.imat } ) ;

    // initialize random states back to the original values...............
    env.initStates = function(){
        env.ftinymtState.data = env.istate ;
        env.stinymtState.data = env.istate ;
    }
/*------------------------------------------------------------------------
 * textures for time-stepping
 *------------------------------------------------------------------------
 */
    env.fcolors = [] ;
    env.scolors = [] ;

    for(var i=0; i<10; i++){
        env['fcolor'+i] = new Abubu.Float32Texture( 
                env.width, env.height, { pairable : true } ) ;
        env['scolor'+i] = new Abubu.Float32Texture( 
                env.width, env.height, { pairable : true } ) ;
        env.fcolors.push(env['fcolor'+i]) ;
        env.scolors.push(env['scolor'+i]) ;
    }
    env.fcolors = [ ...env.fcolors, env.ftinymtState ] ;
    env.scolors = [ ...env.scolors, env.stinymtState ] ;
    
    env.colors = [ ...env.fcolors, ...env.scolors ] ;

/*------------------------------------------------------------------------
 * init solvers
 *------------------------------------------------------------------------
 */
    // init1 .............................................................
    class InitTargets1{
        constructor( colors ){
            for(let i=0; i<6 ; i++){
                this["ocolor"+i] = {location : i, target: colors[i]} ;
            }
        }
    }
    env.finit1 = new Abubu.Solver({
        fragmentShader : source('init1') ,
        targets : new InitTargets1( env.fcolors ) ,
    } ) ;

    env.sinit1 = new Abubu.Solver({
        fragmentShader : source('init1') ,
        targets : new InitTargets1( env.scolors ) ,
    } ) ;


    // init2 .............................................................
    class InitTargets2{
        constructor( colors ){
            for ( let i = 0 ; i< 4 ; i++){
                let j=6+i ;
                this["ocolor"+j] = { location : i, target : colors[j] } ;
            }
        }
    }

    env.finit2 = new Abubu.Solver({
        fragmentShader : source('init2') ,
        targets : new InitTargets2( env.fcolors ) ,
    } ) ;

    env.sinit2 = new Abubu.Solver({
        fragmentShader : source('init2') ,
        targets : new InitTargets2( env.scolors ) ,
    } ) ;


/*------------------------------------------------------------------------
 * Common CompUniforms
 *------------------------------------------------------------------------
 */
    class CompUniforms{
        constructor( obj, floats, ints, txtrs){
            for(let i in floats ){
                let name    = floats[i] ;
                this[name]  = { type :'f', value : obj[name] } ;
            }
            for(let i in ints){
                let name    = ints[i] ;
                this[name]  = { type : 'i', value : obj[name] } ;
            }
            for(let i in txtrs){
                let name = txtrs[i] ;
                this[name] = { type : 't', value : obj[name] } ;
            }
        }
    }

    
    // comp1 .............................................................
    class Comp1Uniforms extends CompUniforms{
        constructor( _fc, _sc ){
            super(env, env.allFloats, env.allInts, env.allTxtrs ) ;
            for(let i =0 ; i <10 ; i++){
                this['icolor'+i] = { type: 't', value : _fc[i] } ;
            }
            this.in_tinymtState = { type : 't', value : _fc[_fc.length-1] } ;
            this.in_tinymtMat   = { type : 't', value : env.tinymtMat };
        }
    }

    class Comp1Targets{
        constructor( _fc,_sc ){
            for(let i=0; i<6 ; i++){
                let j = i ;
                this['ocolor'+i] = {location : i, target : _sc[j] } ;
            }
            this.out_tinymtState
                = { location : 6 , target : _sc[_sc.length-1] } ;
        }
    }

    env.fcomp1 = new Abubu.Solver({
        fragmentShader : source('comp1') ,
        uniforms : new Comp1Uniforms(env.fcolors, env.scolors ) ,
        targets  : new Comp1Targets( env.fcolors, env.scolors ) ,
    } ) ;

    env.scomp1 = new Abubu.Solver({
        fragmentShader : source('comp1') ,
        uniforms : new Comp1Uniforms(env.scolors, env.fcolors ) ,
        targets  : new Comp1Targets( env.scolors, env.fcolors ) ,
    } ) ;

    // comp2 .............................................................
    class Comp2Uniforms extends CompUniforms{
        constructor( _fc, _sc ){
            super(env, env.allFloats, env.allInts, env.allTxtrs ) ;
            for(let i = 0 ; i < 6 ; i++){
                this['icolor'+i] = { type: 't', value : _sc[i] } ;
            }
            for(let i = 6 ; i < 10 ; i++){
                this['icolor'+i] = { type: 't', value : _fc[i] } ;
            }
        }
    }

    class Comp2Targets{
        constructor( _fc,_sc ){
            for(let i=0; i<4 ; i++){
                let j = i + 6 ;
                this['ocolor'+i] = {location : i, target : _sc[j] } ;
            }
        }
    }

    env.fcomp2 = new Abubu.Solver({
        fragmentShader : source('comp2') ,
        uniforms : new Comp2Uniforms(env.fcolors, env.scolors ) ,
        targets  : new Comp2Targets( env.fcolors, env.scolors ) ,
    } ) ;

    env.scomp2 = new Abubu.Solver({
        fragmentShader : source('comp2') ,
        uniforms : new Comp2Uniforms(env.scolors, env.fcolors ) ,
        targets  : new Comp2Targets( env.scolors, env.fcolors ) ,
    } ) ;

/*------------------------------------------------------------------------
 * editors
 *------------------------------------------------------------------------
 */
    // comp1Editor ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    env.comp1Editor = ace.edit("comp1Editor") ;
    env.comp1Editor.setValue(source('comp1'));
    env.comp1Editor.clearSelection() ; 
    env.comp1Editor.setTheme("ace/theme/tomorrow");
    env.comp1Editor.getSession().setMode('ace/mode/glsl') ;
    env.comp1Editor.on( 'change', function(){
        var source = env.comp1Editor.getValue() ;
        if (source.length>12){
            env.fcomp1.fragmentShader = env.comp1Editor.getValue() ;
            env.scomp1.fragmentShader = env.comp1Editor.getValue() ;
        }
    } ) ;

    // Save comp1
    env.saveComp1 = new Abubu.TextWriter({filename: 'comp1.frag'}) ;
    env.saveComp1.onclick = function(){
        env.saveComp1.text = env.comp1Editor.getValue() ;
    }

    // Load comp1
    env.loadComp1 = new Abubu.TextReader() ;
    env.loadComp1.onload = function(){
        var result = env.loadComp1.result ;
        console.log(result) ;
        env.comp1Editor.setValue(result) ;
        env.comp1Editor.clearSelection() ;
    } ;

    // comp2Editor ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    env.comp2Editor = ace.edit("comp2Editor") ;
    env.comp2Editor.setValue(source('comp2'));
    env.comp2Editor.clearSelection() ; 
    env.comp2Editor.setTheme("ace/theme/tomorrow");
    env.comp2Editor.getSession().setMode('ace/mode/glsl') ;
    env.comp2Editor.on( 'change', function(){
        var source = env.comp2Editor.getValue() ;
        if (source.length>12){
            env.fcomp2.fragmentShader = env.comp2Editor.getValue() ;
            env.scomp2.fragmentShader = env.comp2Editor.getValue() ;
        }
    } ) ;

    // Save comp2
    env.saveComp2 = new Abubu.TextWriter({filename: 'comp2.frag'}) ;
    env.saveComp2.onclick = function(){
        env.saveComp2.text = env.comp2Editor.getValue() ;
    }

    // Load comp2
    env.loadComp2 = new Abubu.TextReader() ;
    env.loadComp2.onload = function(){
        var result = env.loadComp2.result ;
        console.log(result) ;
        env.comp2Editor.setValue(result) ;
        env.comp2Editor.clearSelection() ;
    } ;

    // init1Editor ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    env.init1Editor = ace.edit("init1Editor") ;
    env.init1Editor.setValue(source('init1'));
    env.init1Editor.clearSelection() ; 
    env.init1Editor.setTheme("ace/theme/tomorrow");
    env.init1Editor.getSession().setMode('ace/mode/glsl') ;
    env.init1Editor.on( 'change', function(){
        var source = env.init1Editor.getValue() ;
        if (source.length>12){
            env.finit1.fragmentShader = env.init1Editor.getValue() ;
            env.sinit1.fragmentShader = env.init1Editor.getValue() ;
        }
    } ) ;

    // Save init1
    env.saveInit1 = new Abubu.TextWriter({filename: 'init1.frag'}) ;
    env.saveInit1.onclick = function(){
        env.saveInit1.text = env.init1Editor.getValue() ;
    }

    // Load init1
    env.loadInit1 = new Abubu.TextReader() ;
    env.loadInit1.onload = function(){
        var result = env.loadInit1.result ;
        console.log(result) ;
        env.init1Editor.setValue(result) ;
        env.init1Editor.clearSelection() ;
    } ;

    // init2Editor ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    env.init2Editor = ace.edit("init2Editor") ;
    env.init2Editor.setValue(source('init2'));
    env.init2Editor.clearSelection() ; 
    env.init2Editor.setTheme("ace/theme/tomorrow");
    env.init2Editor.getSession().setMode('ace/mode/glsl') ;
    env.init2Editor.on( 'change', function(){
        var source = env.init2Editor.getValue() ;
        if (source.length>12){
            env.finit2.fragmentShader = env.init2Editor.getValue() ;
            env.sinit2.fragmentShader = env.init2Editor.getValue() ;
        }
    } ) ;

    // Save init2
    env.saveInit2 = new Abubu.TextWriter({filename: 'init2.frag'}) ;
    env.saveInit2.onclick = function(){
        env.saveInit2.text = env.init2Editor.getValue() ;
    }

    // Load init2
    env.loadInit2 = new Abubu.TextReader() ;
    env.loadInit2.onload = function(){
        var result = env.loadInit2.result ;
        console.log(result) ;
        env.init2Editor.setValue(result) ;
        env.init2Editor.clearSelection() ;
    } ;


    $(".editor").css('fontSize','10pt') ;

    env.toggleInitEditors = function(){
        $('#initEditors').fadeToggle() ;
    }

    env.toggleCompEditors = function(){
        $('#compEditors').fadeToggle() ;
    }

/*------------------------------------------------------------------------
 * display 
 *------------------------------------------------------------------------
 */
    // volume ray caster .................................................
    env.alphaCorrection = 0.61 ;
    env.structural_alpha = .04 ;
    env.noSteps    = 150 ;
    env.lightShift = 1.2 ;

    env.vrc = new Abubu.VolumeRayCaster({
        target          : env.fcolor0 ,//fphaseTxt,
        phaseField      : env.fphaseTxt,
        compressionMap  : env.compMap,
        canvas          : canvas_1,
        channel         : 'r' ,
        noSteps         : env.noSteps,
        mx              : env.mx,
        my              : env.my ,
        pointLights     : [// 3,3,3,
                           // -3,-3,-3,
                            10,10,10,
                            -10,-10,10,
                        ],
        lightShift      : env.lightShift , 
        floodLights     : [],
        threshold       : 0. ,
        minValue        : 0 ,
        maxValue        : 3. ,
        alphaCorrection : env.alphaCorrection ,
        structural_alpha : env.structural_alpha ,
        colorbar        : true ,
        unit            : ''
    } ) ;

    env.colorplot = env.vrc ;
    env.colorplot.status = env.colorplot.addMessage('Paused!',0.5,0.1 , 
        { 
            font : "14pt Times" ,
            style: '#000000', 
            align: "left"
        }
    ) ;
    env.colorplot.addMessage('Time = ',0.05,0.10 , 
        { 
            font : "14pt Times" ,
            style: "#000000", 
            align: "left"
        }
    ) ;

    env.colorplot.time = env.colorplot.addMessage( '0.00 [ms]', 0.40,0.10 , 
        { 
            font : "14pt Times" ,
            style: "#000000", 
            align: "right"
        }
    ) ;
    env.colorplot.stamp =env.colorplot.addMessage( 'Simulation by Abouzar Kaboudian @ CHAOS Lab ', 0.05,0.05 , 
        { 
            font : "Italic 14pt Times" ,
            style: "#000000", 
            align: "left"
        }
    ) ;
 
    env.colorplot.initForeground() ;

    // signal plot .......................................................
    env.signalplot = new Abubu.SignalPlot({
        noPltPoints : 1024,
        grid : 'on',
        nx : 5,
        ny : 6, 
        xticks : { mode: 'auto', unit : 'ms', font : '11pt Times'} ,
        yticks : { mode: 'auto', unit : 'mv', font : '11pt Times'} ,
        canvas : env.canvas_2 
    } ) ;

    env.voltageSignal = env.signalplot.addSignal( env.fcolor6 ,{
        channel : 'r', 
        minValue : -100 ,
        maxValue : 50 ,
        color :[0.5,0.,0.] ,
        restValue : -90 ,
        visible : true ,
        linewidth : 3,
        timeWindow: 1000 ,
        probePosition : [0.5,0.5] ,
    }) ;

    env.display = function(){
        env.colorplot.time.text = env.time.toFixed(2) + ' [ms]' ;
        env.colorplot.initForeground() ;
        env.colorplot.render() ;
        env.signalplot.render() ;
    }


    // solve or pause simulations ........................................
    env.solveOrPause = function(){
        env.running = !env.running ;
        if (env.running){
            env.colorplot.status.text = 'Running...' ;
        }else{
            env.colorplot.status.text = 'Paused!' ;
        }
    } 

    // initialize the solution using the solvers .........................
    env.init = function(){
        env.time = 0 ;
        env.signalplot.init(env.time) ;
        env.finit1.render() ;
        env.sinit1.render() ;
        env.finit2.render() ;
        env.sinit2.render() ;
        return ;
    }
    env.init() ;

/*------------------------------------------------------------------------
 * createGui
 *------------------------------------------------------------------------
 */
   createGui() ;

/*------------------------------------------------------------------------
 * rendering the program ;
 *------------------------------------------------------------------------
 */
    env.render = function(){
        if (env.running){
            for(var i=0; i<env.skip; i++){
                env.fcomp1.render() ;
                env.fcomp2.render() ;
                env.scomp1.render() ;
                env.scomp2.render() ;
                env.time += env.dt*2. ;
                env.signalplot.update(env.time) ;
            }
        }
        env.display() ;
        requestAnimationFrame(env.render) ;
    }

/*------------------------------------------------------------------------
 * add environment to document
 *------------------------------------------------------------------------
 */
    document.env = env ;

/*------------------------------------------------------------------------
 * render the webgl program
 *------------------------------------------------------------------------
 */
    env.render();

}/*  End of loadWebGL  */

/*========================================================================
 * createGui
 *========================================================================
 */
function createGui(){
    env.gui = new Abubu.Gui() ;
    env.gui.pnl1 = env.gui.addPanel({width:300}) ;
    var pnl1 = env.gui.pnl1 ;
    
    // display ...........................................................
    pnl1.f1 = pnl1.addFolder('Display') ;
    pnl1.f1.add(env.vrc, 'alphaCorrection').min(0).max(1) ;
    pnl1.f1.add(env.vrc, 'structural_alpha').min(0).max(1) ;
    pnl1.f1.add(env.vrc, 'noSteps' ) ;
    pnl1.f1.add(env.vrc, 'lightShift' ) ;
    
    // source code editors ...............................................
    pnl1.f2 = pnl1.addFolder('Source Code Editors' ) ;

    pnl1.f2.f1 = pnl1.f2.addFolder('Compute Shader Editors') ;
    pnl1.f2.f1.add(env, 'toggleCompEditors').name('Show/Hide Editors') ;
    pnl1.f2.f1.add(env.saveComp1, 'fileName').name('comp1 File Name') ;
    pnl1.f2.f1.add(env.saveComp1, 'save').name('Save comp1 to file...') ;
    pnl1.f2.f1.add(env.loadComp1, 'click')
        .name('Load comp1 from file!') ;
    pnl1.f2.f1.add(env.saveComp2, 'fileName').name('comp2 File Name') ;
    pnl1.f2.f1.add(env.saveComp2, 'save').name('Save comp2 to file...') ;
    pnl1.f2.f1.add(env.loadComp2, 'click')
        .name('Load comp2 from file!') ;

    pnl1.f2.f1.open() ;

    pnl1.f2.f2 = pnl1.f2.addFolder('Init Shader Editors') ;
    pnl1.f2.f2.add(env, 'toggleInitEditors').name('Show/Hide Editors') ;
    pnl1.f2.f2.add(env.saveInit1, 'fileName').name('init1 File Name') ;
    pnl1.f2.f2.add(env.saveInit1, 'save').name('Save init1 to file...') ;
    pnl1.f2.f2.add(env.loadInit1, 'click')
        .name('Load init1 from file!') ;
    pnl1.f2.f2.add(env.saveInit2, 'fileName').name('init2 File Name') ;
    pnl1.f2.f2.add(env.saveInit2, 'save').name('Save init2 to file...') ;
    pnl1.f2.f2.add(env.loadInit2, 'click')
        .name('Load init2 from file!') ;

    pnl1.f2.f2.open() ;
    

    // simulation ........................................................
    pnl1.f3 = pnl1.addFolder('Simulation') ;
    pnl1.f3.add(env, 'skip' ) ;
    pnl1.f3.add(env, 'init' ).name('Initialize Solution') ;
    pnl1.f3.add(env, 'solveOrPause').name('Solve/Pause') ;
    pnl1.f3.add(env, 'time').name('Solution Time [ms]').listen() ;
    pnl1.f3.open() ;
    return ;
} /* End of createGui */
</script>


</body>
</html>

